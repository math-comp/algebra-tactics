% [eucldiv N D M R] N = D * M + R
pred eucldiv o:int, i:int, o:int, i:int.
eucldiv N D M R :- var N, var M, !, declare_constraint (eucldiv N D M R) [N, M].
eucldiv N D M R :- var N, N is D * M + R.
eucldiv N D M R :- var M, M is N div D, R is N mod D.

pred positive-constant o:int, o:term.
positive-constant 1 {{ lib:num.pos.xH }} :- !.
positive-constant N {{ lib:num.pos.xO lp:T }} :-
  eucldiv N 2 M 0, positive-constant M T.
positive-constant N {{ lib:num.pos.xI lp:T }} :-
  eucldiv N 2 M 1, positive-constant M T.

pred n-constant o:int, o:term.
n-constant N _ :- not (var N), N < 0, !, fail.
n-constant 0 {{ lib:num.N.N0 }} :- !.
n-constant N {{ lib:num.N.Npos lp:T }} :- !, positive-constant N T.

pred z-constant o:int, o:term.
z-constant 0 {{ lib:num.Z.Z0 }} :- !.
z-constant N T :-
  var T, N < 0, !,
  T = {{ lib:num.Z.Zneg lp:T' }}, positive-constant {calc (~ N)} T'.
z-constant N T :-
  var T, 0 < N, !, T = {{ lib:num.Z.Zpos lp:T' }}, positive-constant N T'.
z-constant N {{ lib:num.Z.Zneg lp:T }} :-
  var N, !, positive-constant N' T, N is ~ N'.
z-constant N {{ lib:num.Z.Zpos lp:T }} :-
  var N, !, positive-constant N T.

pred int->nat i:int, o:term.
int->nat 0 {{ lib:num.nat.O }} :- !.
int->nat SN {{ lib:num.nat.S lp:M }} :- !, int->nat {calc (SN - 1)} M.
int->nat N T :- coq.error "int->nat" N T.

pred nat->int i:term, o:int.
nat->int {{ lib:num.nat.O }} 0 :- !.
nat->int {{ lib:num.nat.S lp:M }} SN :- nat->int M N, SN is N + 1.

pred list-constant o:term, o:list term, o:term.
list-constant T [] {{ @nil lp:T }} :- !.
list-constant T [X|XS] {{ @cons lp:T lp:X lp:XS' }} :- list-constant T XS XS'.

pred int->list i:int, o:list A.
int->list N _  :- N < 0, !, fail.
int->list 0 [] :- !.
int->list N [_|XS] :- int->list {calc (N - 1)} XS.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

pred mem o:list term, o:term, o:int.
mem [X|_] X 0 :- !.
mem [_|XS] X M :- !, mem XS X N, M is N + 1.

pred close o:list term.
close [] :- !.
close [_|XS] :- close XS.

% [field-mode] is true if the target is a field equation.
pred field-mode.

pred quote.expr.variable i:term, o:term.
quote.expr.variable In {{ @FEX Z lp:In }} :- field-mode, !.
quote.expr.variable In {{ @PEX Z lp:In }} :- !.

pred quote.expr.constant i:term, o:term.
quote.expr.constant In {{ @FEc Z lp:In }} :- field-mode, !.
quote.expr.constant In {{ @PEc Z lp:In }} :- !.

pred quote.expr.zero o:term.
quote.expr.zero {{ @FEO Z }} :- field-mode, !.
quote.expr.zero {{ @PEO Z }} :- !.

pred quote.expr.opp i:term, o:term.
quote.expr.opp In {{ @FEopp Z lp:In }} :- field-mode, !.
quote.expr.opp In {{ @PEopp Z lp:In }} :- !.

pred quote.expr.add i:term, i:term, o:term.
quote.expr.add In1 In2 {{ @FEadd Z lp:In1 lp:In2 }} :- field-mode, !.
quote.expr.add In1 In2 {{ @PEadd Z lp:In1 lp:In2 }} :- !.

pred quote.expr.one o:term.
quote.expr.one {{ @FEI Z }} :- field-mode, !.
quote.expr.one {{ @PEI Z }} :- !.

pred quote.expr.mul i:term, i:term, o:term.
quote.expr.mul In1 In2 {{ @FEmul Z lp:In1 lp:In2 }} :- field-mode, !.
quote.expr.mul In1 In2 {{ @PEmul Z lp:In1 lp:In2 }} :- !.

pred quote.expr.exp i:term, i:term, o:term.
quote.expr.exp In1 In2 {{ @FEpow Z lp:In1 lp:In2 }} :- field-mode, !.
quote.expr.exp In1 In2 {{ @PEpow Z lp:In1 lp:In2 }} :- !.

% [ring->field Ring Field]: [Field] is optionally a [fieldType] instance such
% that [GRing.Field.ringType Field = Ring].
pred ring->field i:term, o:option term.
ring->field Ring (some Field) :-
  field-mode,
  coq.unify-eq {{ GRing.Ring.sort lp:Ring }} {{ GRing.Field.sort lp:Field }} ok,
  !.
ring->field _ none.

% [quote.nat Ring Input OutM Out VarMap]
% - [Ring] is a [ringType] instance,
% - [Input] is a term of type [nat],
% - [OutM] and [Out] are reified terms of [Input], and
% - [VarMap] is a variable map.
pred quote.nat i:term, i:term, o:term, o:term, o:list term.
quote.nat _ {{ lib:num.nat.O }} {{ NatC lib:num.N.N0 }} Out _ :- !,
  quote.expr.constant { z-constant 0 } Out.
quote.nat Ring {{ lib:num.nat.S lp:In }} OutM Out VarMap :- !,
  quote.count-succ In N In2, !,
  positive-constant {calc (N + 1)} Out1, !,
  if (In2 = {{ lib:num.nat.O }})
     (OutM = {{ NatC (lib:num.N.Npos lp:Out1) }},
      quote.expr.constant {{ lib:num.Z.Zpos lp:Out1 }} Out)
     (quote.nat Ring In2 OutM2 Out2 VarMap, !,
      OutM = {{ NatAdd (NatC (lib:num.N.Npos lp:Out1)) lp:OutM2 }},
      quote.expr.add
        {quote.expr.constant {{ lib:num.Z.Zpos lp:Out1 }} } Out2 Out).
quote.nat Ring {{ addn lp:In1 lp:In2 }}
               {{ NatAdd lp:OutM1 lp:OutM2 }} Out VarMap :- !,
  quote.nat Ring In1 OutM1 Out1 VarMap, !,
  quote.nat Ring In2 OutM2 Out2 VarMap, !,
  quote.expr.add Out1 Out2 Out.
quote.nat Ring {{ muln lp:In1 lp:In2 }}
               {{ NatMul lp:OutM1 lp:OutM2 }} Out VarMap :- !,
  quote.nat Ring In1 OutM1 Out1 VarMap, !,
  quote.nat Ring In2 OutM2 Out2 VarMap, !,
  quote.expr.mul Out1 Out2 Out.
quote.nat Ring {{ expn lp:In1 lp:In2 }}
               {{ NatExp lp:OutM1 lp:Out2 }} Out VarMap :-
  coq.reduction.vm.norm {{ N.of_nat lp:In2 }} {{ N }} Out2,
  n-constant _ Out2,
  !,
  quote.nat Ring In1 OutM1 Out1 VarMap, !,
  quote.expr.exp Out1 Out2 Out.
% For now, we normalize some specific form of terms of type nat.
quote.nat _ {{ Nat.of_num_uint lp:In }} {{ NatC lp:OutM }} Out _ :-
  nat->int { coq.reduction.vm.norm {{ Nat.of_num_uint lp:In }} {{ nat }} } N,
  !,
  n-constant N OutM,
  quote.expr.constant { z-constant N } Out.
quote.nat Ring In {{ NatX lp:In }} Out VarMap :- !,
  Zmodule = {{ GRing.Ring.zmodType lp:Ring }},
  mem VarMap {{ @GRing.natmul lp:Zmodule (@GRing.one lp:Ring) lp:In }} N, !,
  quote.expr.variable { positive-constant {calc (N + 1)} } Out.

pred quote.count-succ i:term, o:int, o:term.
quote.count-succ {{ lib:num.nat.S lp:In }} N' Out :- !,
  quote.count-succ In N Out, N' is N + 1.
quote.count-succ In 0 In :- !.

% [quote.zmod SrcZmodule TgtRing MorphFun Morph Input OutM Out VarMap]
% - [SrcZmodule] is a [zmodType] instance,
% - [TgtRing] is a [ringType] instance,
% - [Morph] is an additive function from [SrcZmodule] to [TgtRing] whose
%   underlying function is [MorphFun],
% - [Input] is a term of type [SrcZmodule],
% - [OutM] and [Out] are reified terms of [Input], and
% - [VarMap] is a variable map.
pred quote.zmod i:term, i:term, i:(term -> term), i:term, i:term,
                o:term, o:term, o:list term.
% 0%R
quote.zmod SrcZmodule _ _ _ {{ @GRing.zero lp:SrcZmodule' }}
           {{ @Zmod0 lp:SrcZmodule }} Out _ :-
  coq.unify-eq {{ @GRing.zero lp:SrcZmodule }}
               {{ @GRing.zero lp:SrcZmodule' }} ok, !,
  quote.expr.zero Out.
% -%R
quote.zmod SrcZmodule TgtRing MorphFun Morph
           {{ @GRing.opp lp:SrcZmodule' lp:In1 }}
           {{ @ZmodOpp lp:SrcZmodule lp:OutM1 }} Out VarMap :-
  coq.unify-eq {{ @GRing.opp lp:SrcZmodule }}
               {{ @GRing.opp lp:SrcZmodule' }} ok,
  !,
  quote.zmod SrcZmodule TgtRing MorphFun Morph In1 OutM1 Out1 VarMap, !,
  quote.expr.opp Out1 Out.
% +%R
quote.zmod SrcZmodule TgtRing MorphFun Morph
           {{ @GRing.add lp:SrcZmodule' lp:In1 lp:In2 }}
           {{ @ZmodAdd lp:SrcZmodule lp:OutM1 lp:OutM2 }} Out VarMap :-
  coq.unify-eq {{ @GRing.add lp:SrcZmodule }}
               {{ @GRing.add lp:SrcZmodule' }} ok,
  !,
  quote.zmod SrcZmodule TgtRing MorphFun Morph In1 OutM1 Out1 VarMap, !,
  quote.zmod SrcZmodule TgtRing MorphFun Morph In2 OutM2 Out2 VarMap, !,
  quote.expr.add Out1 Out2 Out.
% (_ *+ _)%R
quote.zmod SrcZmodule TgtRing MorphFun Morph
           {{ @GRing.natmul lp:SrcZmodule' lp:In1 lp:In2 }}
           {{ @ZmodMuln lp:SrcZmodule lp:OutM1 lp:OutM2 }} Out VarMap :-
  coq.unify-eq SrcZmodule SrcZmodule' ok,
  !,
  quote.zmod SrcZmodule TgtRing MorphFun Morph In1 OutM1 Out1 VarMap, !,
  quote.nat TgtRing In2 OutM2 Out2 VarMap, !,
  quote.expr.mul Out1 Out2 Out.
% (_ *~ _)%R
quote.zmod SrcZmodule TgtRing MorphFun Morph
           {{ @intmul lp:SrcZmodule' lp:In1 lp:In2 }}
           {{ @ZmodMulz lp:SrcZmodule lp:OutM1 lp:OutM2 }} Out VarMap :-
  coq.unify-eq SrcZmodule SrcZmodule' ok,
  !,
  quote.zmod SrcZmodule TgtRing MorphFun Morph In1 OutM1 Out1 VarMap, !,
  quote.ring
    {{ int_Ring }} none TgtRing
    (n\ {{ @intmul (GRing.Ring.zmodType lp:TgtRing)
                   (@GRing.one lp:TgtRing) lp:n }})
    {{ @intmul1_rmorphism lp:TgtRing }} In2 OutM2 Out2 VarMap, !,
  quote.expr.mul Out1 Out2 Out.
% additive functions
quote.zmod SrcZmodule TgtRing MorphFun Morph In
           {{ @ZmodMorph lp:NewSrcZmodule lp:SrcZmodule lp:NewMorph lp:OutM }}
           Out VarMap :-
  TgtZmodule = {{ @GRing.Ring.zmodType lp:TgtRing }},
  NewMorphFun = (x\ {{ @GRing.Additive.apply
                       lp:NewSrcZmodule lp:SrcZmodule _ lp:NewMorph lp:x }}),
  coq.unify-eq In (NewMorphFun In1) ok,
  !,
  % TODO: for concrete additive functions, should we unpack [NewMorph]?
  CompMorph = {{ @GRing.comp_additive lp:NewSrcZmodule
                 lp:SrcZmodule lp:TgtZmodule lp:Morph lp:NewMorph }},
  quote.zmod NewSrcZmodule TgtRing (x\ MorphFun (NewMorphFun x)) CompMorph
             In1 OutM Out VarMap.
% variables
quote.zmod SrcZmodule _ MorphFun _ In
           {{ @ZmodX lp:SrcZmodule lp:In }} Out VarMap :-
  mem VarMap (MorphFun In) N,
  quote.expr.variable { positive-constant {calc (N + 1)} } Out,
  !.
quote.zmod _ _ _ _ In _ _ _ :- coq.error "Unknown" {coq.term->string In}.

% [quote.ring SrcRing SrcField TgtRing MorphFun Morph Input OutM Out VarMap]
% - [SrcRing] and [TgtRing] are [ringType] instances,
% - [SrcField] is optionally a [fieldType] instance such that
%   [GRing.Field.ringType SrcField = SrcRing],
% - [Morph] is a ring morphism from [SrcRing] to [TgtRing] whose underlying
%   function is [MorphFun],
% - [Input] is a term of type [SrcRing],
% - [OutM] and [Out] are reified terms of [Input], and
% - [VarMap] is a variable map.
pred quote.ring i:term, i:option term, i:term, i:(term -> term), i:term,
                i:term, o:term, o:term, o:list term.
% 0%R
quote.ring SrcRing _ _ _ _ {{ @GRing.zero lp:SrcZmodule }}
           {{ @Ring0 lp:SrcRing }} Out _ :-
  coq.unify-eq {{ @GRing.zero lp:SrcZmodule }}
               {{ @GRing.zero (GRing.Ring.zmodType lp:SrcRing) }} ok, !,
  quote.expr.zero Out.
% -%R
quote.ring SrcRing SrcField TgtRing MorphFun Morph
           {{ @GRing.opp lp:SrcZmodule lp:In1 }}
           {{ @RingOpp lp:SrcRing lp:OutM1 }} Out VarMap :-
  coq.unify-eq {{ @GRing.opp lp:SrcZmodule }}
               {{ @GRing.opp (GRing.Ring.zmodType lp:SrcRing) }} ok,
  !,
  quote.ring SrcRing SrcField TgtRing MorphFun Morph In1 OutM1 Out1 VarMap, !,
  quote.expr.opp Out1 Out.
% Z.opp
quote.ring SrcRing none TgtRing MorphFun Morph
           {{ Z.opp lp:In1 }} {{ @RingZOpp lp:OutM1 }} Out VarMap :-
  coq.unify-eq {{ ZInstances.Z_ringType }} SrcRing ok,
  !,
  quote.ring SrcRing none TgtRing MorphFun Morph In1 OutM1 Out1 VarMap, !,
  quote.expr.opp Out1 Out.
% +%R
quote.ring SrcRing SrcField TgtRing MorphFun Morph
           {{ @GRing.add lp:SrcZmodule lp:In1 lp:In2 }}
           {{ @RingAdd lp:SrcRing lp:OutM1 lp:OutM2 }} Out VarMap :-
  coq.unify-eq {{ @GRing.add lp:SrcZmodule }}
               {{ @GRing.add (GRing.Ring.zmodType lp:SrcRing) }} ok,
  !,
  quote.ring SrcRing SrcField TgtRing MorphFun Morph In1 OutM1 Out1 VarMap, !,
  quote.ring SrcRing SrcField TgtRing MorphFun Morph In2 OutM2 Out2 VarMap, !,
  quote.expr.add Out1 Out2 Out.
% Z.add
quote.ring SrcRing none TgtRing MorphFun Morph
           {{ Z.add lp:In1 lp:In2 }} {{ @RingZAdd lp:OutM1 lp:OutM2 }}
           Out VarMap :-
  coq.unify-eq {{ ZInstances.Z_ringType }} SrcRing ok,
  !,
  quote.ring SrcRing none TgtRing MorphFun Morph In1 OutM1 Out1 VarMap, !,
  quote.ring SrcRing none TgtRing MorphFun Morph In2 OutM2 Out2 VarMap, !,
  quote.expr.add Out1 Out2 Out.
% Z.sub
quote.ring SrcRing none TgtRing MorphFun Morph
           {{ Z.sub lp:In1 lp:In2 }} {{ @RingZSub lp:OutM1 lp:OutM2 }}
           Out VarMap :-
  coq.unify-eq {{ ZInstances.Z_ringType }} SrcRing ok,
  !,
  quote.ring SrcRing none TgtRing MorphFun Morph In1 OutM1 Out1 VarMap, !,
  quote.ring SrcRing none TgtRing MorphFun Morph In2 OutM2 Out2 VarMap, !,
  quote.expr.add Out1 { quote.expr.opp Out2 } Out.
% (_ *+ _)%R
quote.ring SrcRing SrcField TgtRing MorphFun Morph
           {{ @GRing.natmul lp:SrcZmodule lp:In1 lp:In2 }}
           {{ @RingMuln lp:SrcRing lp:OutM1 lp:OutM2 }} Out VarMap :-
  coq.unify-eq SrcZmodule {{ @GRing.Ring.zmodType lp:SrcRing }} ok,
  !,
  quote.ring SrcRing SrcField TgtRing MorphFun Morph In1 OutM1 Out1 VarMap, !,
  quote.nat TgtRing In2 OutM2 Out2 VarMap, !,
  quote.expr.mul Out1 Out2 Out.
% (_ *~ _)%R
quote.ring SrcRing SrcField TgtRing MorphFun Morph
           {{ @intmul lp:SrcZmodule lp:In1 lp:In2 }}
           {{ @RingMulz lp:SrcRing lp:OutM1 lp:OutM2 }} Out VarMap :-
  coq.unify-eq SrcZmodule {{ @GRing.Ring.zmodType lp:SrcRing }} ok,
  !,
  quote.ring SrcRing SrcField TgtRing MorphFun Morph In1 OutM1 Out1 VarMap, !,
  quote.ring
    {{ int_Ring }} none TgtRing
    (n\ {{ @intmul (GRing.Ring.zmodType lp:TgtRing)
                   (@GRing.one lp:TgtRing) lp:n }})
    {{ @intmul1_rmorphism lp:TgtRing }} In2 OutM2 Out2 VarMap, !,
  quote.expr.mul Out1 Out2 Out.
% 1%R
quote.ring SrcRing _ _ _ _ {{ @GRing.one lp:SrcRing' }}
           {{ @Ring1 lp:SrcRing }} Out _ :-
  coq.unify-eq {{ @GRing.one lp:SrcRing' }} {{ @GRing.one lp:SrcRing }} ok,
  !,
  quote.expr.one Out.
% *%R
quote.ring SrcRing SrcField TgtRing MorphFun Morph
           {{ @GRing.mul lp:SrcRing' lp:In1 lp:In2 }}
           {{ @RingMul lp:SrcRing lp:OutM1 lp:OutM2 }} Out VarMap :-
  coq.unify-eq {{ @GRing.mul lp:SrcRing' }} {{ @GRing.mul lp:SrcRing }} ok,
  !,
  quote.ring SrcRing SrcField TgtRing MorphFun Morph In1 OutM1 Out1 VarMap, !,
  quote.ring SrcRing SrcField TgtRing MorphFun Morph In2 OutM2 Out2 VarMap, !,
  quote.expr.mul Out1 Out2 Out.
% Z.mul
quote.ring SrcRing none TgtRing MorphFun Morph
           {{ Z.mul lp:In1 lp:In2 }} {{ @RingZMul lp:OutM1 lp:OutM2 }}
           Out VarMap :-
  coq.unify-eq {{ ZInstances.Z_ringType }} SrcRing ok,
  !,
  quote.ring SrcRing none TgtRing MorphFun Morph In1 OutM1 Out1 VarMap, !,
  quote.ring SrcRing none TgtRing MorphFun Morph In2 OutM2 Out2 VarMap, !,
  quote.expr.mul Out1 Out2 Out.
% (_ ^+ _)%R
quote.ring SrcRing SrcField TgtRing MorphFun Morph
           {{ @GRing.exp lp:SrcRing' lp:In1 lp:In2 }}
           {{ @RingExpn lp:SrcRing lp:OutM1 lp:Out2 }} Out VarMap :-
  coq.unify-eq SrcRing' SrcRing ok,
  n-constant { nat->int { coq.reduction.vm.norm In2 {{ nat }} } } Out2,
  !,
  quote.ring SrcRing SrcField TgtRing MorphFun Morph In1 OutM1 Out1 VarMap, !,
  quote.expr.exp Out1 Out2 Out.
% (_ ^ _)%R
quote.ring SrcRing SrcField TgtRing MorphFun Morph
           {{ @exprz lp:SrcUnitRing lp:In1 lp:In2 }} OutM Out VarMap :-
  z-constant Exp { coq.reduction.vm.norm {{ Z_of_int lp:In2 }} {{ Z }} },
  if (Exp >= 0)
     (CONT =
       (coq.unify-eq {{ GRing.UnitRing.ringType lp:SrcUnitRing }} SrcRing ok, !,
        quote.ring
          SrcRing SrcField TgtRing MorphFun Morph In1 OutM1 Out1 VarMap, !,
        n-constant Exp Out2, !,
        OutM = {{ @RingExpPosz lp:SrcUnitRing lp:OutM1 lp:Out2 }}, !,
        quote.expr.exp Out1 Out2 Out))
     (CONT =
       (field-mode,
        SrcField = some SrcField',
        coq.unify-eq {{ lp:SrcUnitRing }}
                     {{ GRing.Field.unitRingType lp:SrcField' }} ok, !,
        quote.ring
          SrcRing SrcField TgtRing MorphFun Morph In1 OutM1 Out1 VarMap, !,
        n-constant { calc (~ (Exp + 1)) } Out2, !,
        OutM = {{ @RingExpNegz lp:SrcField' lp:OutM1 lp:Out2 }}, !,
        Out = {{ @FEinv Z (@FEpow Z lp:Out1 lp:Out2) }})),
  CONT.
% Z.pow
quote.ring SrcRing none TgtRing MorphFun Morph
           {{ Z.pow lp:In1 lp:In2 }} {{ @RingZExp lp:OutM1 lp:In2' }}
           Out VarMap :-
  coq.unify-eq {{ ZInstances.Z_ringType }} SrcRing ok,
  coq.reduction.vm.norm In2 {{ Z }} In2',
  z-constant Exp In2',
  !,
  if (Exp >= 0)
     (quote.ring SrcRing none TgtRing MorphFun Morph In1 OutM1 Out1 VarMap,
      n-constant Exp Out2,
      quote.expr.exp Out1 Out2 Out)
     (quote.expr.zero Out).
% _^-1
quote.ring SrcRing (some SrcField) TgtRing MorphFun Morph
           {{ @GRing.inv lp:SrcUnitRing lp:In1 }}
           {{ @RingInv lp:SrcField lp:OutM1 }} {{ @FEinv Z lp:Out1 }} VarMap :-
  field-mode,
  coq.unify-eq {{ @GRing.inv lp:SrcUnitRing }}
               {{ @GRing.inv (GRing.Field.unitRingType lp:SrcField) }} ok,
  !,
  quote.ring SrcRing (some SrcField) TgtRing MorphFun Morph
             In1 OutM1 Out1 VarMap.
% Posz
quote.ring SrcRing _ TgtRing _ _
           {{ Posz lp:In }} {{ @RingPosz lp:OutM }} Out VarMap :-
  coq.unify-eq {{ int_Ring }} SrcRing ok,
  !,
  quote.nat TgtRing In OutM Out VarMap.
% Negz
quote.ring SrcRing _ TgtRing _ _ {{ Negz lp:In }}
           {{ @RingNegz lp:OutM1 }} Out VarMap :-
  coq.unify-eq {{ int_Ring }} SrcRing ok,
  !,
  quote.nat TgtRing In OutM1 Out1 VarMap, !,
  quote.expr.opp { quote.expr.add { quote.expr.one } Out1 } Out.
% Z constants
quote.ring SrcRing _ _ _ _ In {{ @RingZC lp:In }} Out _ :-
  coq.unify-eq {{ ZInstances.Z_ringType }} SrcRing ok,
  z-constant _ In, !,
  quote.expr.constant In Out.
% morphisms
quote.ring SrcRing _ TgtRing MorphFun Morph
           {{ @GRing.RMorphism.apply
                lp:NewSrcRing lp:SrcRing' _ lp:NewMorph lp:In }}
           OutM Out VarMap :-
  coq.unify-eq SrcRing SrcRing' ok, !,
  quote.ring.morphism
    NewSrcRing SrcRing TgtRing NewMorph MorphFun Morph In OutM Out VarMap.
% morphism (canonical instance)
quote.ring SrcRing _ TgtRing MorphFun Morph
           (app [global InHead | _] as In) OutM Out VarMap :-
  coq.CS.db-for {{:gref GRing.RMorphism.apply }} (cs-gref InHead)
                [cs-instance _ _ NewMorphRef],
  NewMorph =
    app [global NewMorphRef |
         { int->list { coq.count-prods { coq.env.typeof NewMorphRef } } }],
  coq.unify-eq
    {{ @GRing.RMorphism.apply lp:NewSrcRing lp:SrcRing _ lp:NewMorph lp:In1 }}
    In ok, !,
  quote.ring.morphism
    NewSrcRing SrcRing TgtRing NewMorph MorphFun Morph In1 OutM Out VarMap.
% additive functions
quote.ring SrcRing _ TgtRing MorphFun Morph In
           {{ @RingMorph' lp:NewSrcZmodule lp:SrcRing lp:NewMorph lp:OutM }}
           Out VarMap :-
  SrcZmodule = {{ GRing.Ring.zmodType lp:SrcRing }},
  TgtZmodule = {{ GRing.Ring.zmodType lp:TgtRing }},
  NewMorphFun = (x\ {{ @GRing.Additive.apply lp:NewSrcZmodule
                       lp:SrcZmodule _ lp:NewMorph lp:x }}),
  coq.unify-eq In (NewMorphFun In1) ok,
  !,
  % TODO: for concrete additive functions, should we unpack [NewMorph]?
  Morph' = {{ GRing.RMorphism.additive lp:SrcRing lp:TgtRing
              (Phant (GRing.Ring.sort lp:SrcRing -> GRing.Ring.sort lp:TgtRing))
              lp:Morph }},
  CompMorph = {{ @GRing.comp_additive lp:NewSrcZmodule
                 lp:SrcZmodule lp:TgtZmodule lp:Morph' lp:NewMorph }},
  quote.zmod NewSrcZmodule TgtRing
             (x\ MorphFun (NewMorphFun x)) CompMorph In1 OutM Out VarMap.
% variables
quote.ring SrcRing _ _ MorphFun _ In {{ @RingX lp:SrcRing lp:In }} Out VarMap :- !,
  mem VarMap (MorphFun In) N, !,
  quote.expr.variable { positive-constant {calc (N + 1)} } Out.
quote.ring _ _ _ _ _ In _ _ _ :- coq.error "Unknown" {coq.term->string In}.
% TODO: converse ring

pred quote.ring.morphism
  i:term, i:term, i:term, i:term, i:(term -> term), i:term, i:term,
  o:term, o:term, o: list term.
% quote.ring.morphism
%     SrcRing MidRing TgtRing NewMorph MorphFun Morph In
%     {{ @RingMorph lp:SrcRing lp:MidRing lp:NewMorph lp:OutM }} Out VarMap :-
%   coq.unify-eq {{ @GRing.RMorphism.Pack _ _ _ (fun x => lp:(NewMorphFun x)) _ }}
%                NewMorph ok,
%   !,
%   quote.ring SrcRing { ring->field SrcRing } TgtRing
%              (x\ MorphFun (NewMorphFun x))
%              {{ @GRing.comp_rmorphism lp:SrcRing lp:MidRing lp:TgtRing
%                                       lp:Morph lp:NewMorph }}
%              In OutM Out VarMap.
quote.ring.morphism
    SrcRing MidRing TgtRing NewMorph MorphFun Morph In
    {{ @RingMorph lp:SrcRing lp:MidRing lp:NewMorph lp:OutM }} Out VarMap :- !,
  Phant =
    {{ Phant (GRing.Ring.sort lp:SrcRing -> GRing.Ring.sort lp:MidRing) }},
  CompMorphFun = (x\ MorphFun {{ @GRing.RMorphism.apply
                    lp:SrcRing lp:MidRing lp:Phant lp:NewMorph lp:x }}),
  CompMorph = {{ @GRing.comp_rmorphism
                   lp:SrcRing lp:MidRing lp:TgtRing lp:Morph lp:NewMorph }},
  quote.ring SrcRing { ring->field SrcRing } TgtRing
             CompMorphFun CompMorph In OutM Out VarMap.
